"""
    MCP_model(data::ModelData; subterms = false)

Creates a Mixed Complementarity Problem (MCP) model based on the provided `ModelData`.
If `subterms` is set to `true`, intermediate variables for revenues and costs are created
for better clarity in the model formulation.

This model is included as an example of the explict MCP equation generated by MPSGE. 
It was initially created to test a bug. This model will solve for most parameter values
if `subterms=false`, but may fail to solve for some parameter values if `subterms=true`.

The [`report`](@ref) will *not* work with this model. 
"""
function MCP_model(data::ModelData; subterms = false)
    E0 = data.initial_exports
    M0 = data.initial_imports
    X0 = data.initial_production
    Q0 = data.initial_consumption
    DD0 = data.domestic_demand
    DS0 = data.domestic_supply
    P0 = data.initial_consumer_price_index
    PDD0 = data.initial_domestic_price
    PWE0 = data.initial_world_export_price
    PWM0 = data.initial_world_import_price



    MCP = Model(PATHSolver.Optimizer)

    @variables(MCP, begin
        sigma in JuMP.Parameter(.2)
        omega in JuMP.Parameter(.2)
        BBAR in JuMP.Parameter(0.0)
        PWE in JuMP.Parameter(PWE0)
        PWM in JuMP.Parameter(PWM0)
        TM in JuMP.Parameter(0.0)
        TE in JuMP.Parameter(0.0)
        TD in JuMP.Parameter(0.0)

        X>=0, (start = 1)
        Q>=0, (start = 1)

        PFX>=0, (start = 1)
        PX>=0, (start = 1)
        PQ>=0, (start = 1)
        PDT>=0, (start = 1)

        Y>=0, (start = 100)

    end)

    # Zero Profit
    export_price = PFX*PWE*(1 + TE)


    rev_X = (DS0/(DS0+E0)*(PDT)^(1+omega) + (E0)/(DS0+E0)*export_price^(1+omega))^(1/(1+omega))

    if subterms

        @variables(MCP, begin
            revenue_X, (start = 1)
            cost_X, (start = 1)
        end)

        @constraint(MCP, Revenue_X,
            revenue_X - rev_X ⟂ revenue_X
        )
        @constraint(MCP, Cost_X,
            cost_X - PX ⟂ cost_X
        )

    else
        cost_X = PX
        revenue_X = rev_X

    end

    @constraint(MCP, zp_X,
        cost_X - revenue_X ⟂ X
    )

    cd_X_PFX = E0*PWE * (revenue_X/export_price)^(-omega)
    cd_X_PDT = DS0 * (revenue_X/PDT)^(-omega)
    cd_X_PX = X0

    import_price = PFX*PWM*(1 + TM)
    domestic_price = PDT*(1+TD)
    C_Q = ifelse(sigma == 1,
            import_price^(M0/(M0+DD0)) * domestic_price^(DD0/(M0+DD0)),
            ((M0)/(M0+DD0)*import_price^(1-sigma) + DD0/(M0+DD0)*domestic_price^(1-sigma))^(1/(1-sigma))
        )

    if subterms 
        @variables(MCP, begin
            revenue_Q, (start = 1)
            cost_Q, (start = 1)
        end)
        @constraint(MCP, Revenue_Q, 
            revenue_Q - PQ ⟂ revenue_Q
        )
        @constraint(MCP, Cost_Q,
            cost_Q - C_Q ⟂ cost_Q
        )
    else
        revenue_Q = PQ
        cost_Q = C_Q
    end
    @constraint(MCP, zp_Q,
        cost_Q - revenue_Q ⟂ Q
    )


    cd_Q_PFX = M0*PWM * (cost_Q/import_price)^(sigma)
    cd_Q_PDT = DD0 * (cost_Q/domestic_price)^(sigma)
    cd_Q_PQ = Q0



    # Market Clearance

    # PX
    @constraint(MCP, mc_PX,
        X0 - X*cd_X_PX ⟂ PX
    )

    # PQ
    @constraint(MCP, mc_PQ,
        Q*cd_Q_PQ - Y/PQ ⟂ PQ
    )

    # PDT
    @constraint(MCP, mc_PDT,
        X*cd_X_PDT - Q*cd_Q_PDT ⟂ PDT
    )


    # PFX
    @constraint(MCP, mc_PFX,
        X*cd_X_PFX - Q*cd_Q_PFX + BBAR ⟂ PFX
    )

    # Income Balance
    tax_revenue =  -X*cd_X_PFX*TE*PFX + Q*cd_Q_PFX*TM*PFX + Q*cd_Q_PDT*TD*PDT
    @constraint(MCP, income_balance,
        Y - PX*X0 - BBAR*PFX - tax_revenue ⟂ Y
    )

    fix(PQ, 1; force=true)

    return MCP

end