<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conversion Process · NLP_to_MPSGE_Example.jl</title><meta name="title" content="Conversion Process · NLP_to_MPSGE_Example.jl"/><meta property="og:title" content="Conversion Process · NLP_to_MPSGE_Example.jl"/><meta property="twitter:title" content="Conversion Process · NLP_to_MPSGE_Example.jl"/><meta name="description" content="Documentation for NLP_to_MPSGE_Example.jl."/><meta property="og:description" content="Documentation for NLP_to_MPSGE_Example.jl."/><meta property="twitter:description" content="Documentation for NLP_to_MPSGE_Example.jl."/><meta property="og:url" content="https://github.com/julia-mpsge/NLP_to_MPSGE_Example/convert/"/><meta property="twitter:url" content="https://github.com/julia-mpsge/NLP_to_MPSGE_Example/convert/"/><link rel="canonical" href="https://github.com/julia-mpsge/NLP_to_MPSGE_Example/convert/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../problem_description/">NLP_to_MPSGE_Example.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../problem_description/">Problem Description</a></li><li class="is-active"><a class="tocitem" href>Conversion Process</a><ul class="internal"><li><a class="tocitem" href="#Ignoring-Parameters"><span>Ignoring Parameters</span></a></li><li><a class="tocitem" href="#Final-Thoughts"><span>Final Thoughts</span></a></li></ul></li><li><a class="tocitem" href="../compare/">Comparing Models</a></li></ul></li><li><span class="tocitem">Issues</span><ul><li><a class="tocitem" href="../problems/">Issues with PATHSolver</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../docs/">API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Introduction</a></li><li class="is-active"><a href>Conversion Process</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conversion Process</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/julia-mpsge/NLP_to_MPSGE_Example" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/julia-mpsge/NLP_to_MPSGE_Example/blob/main/docs/src/convert.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Conversion-Process"><a class="docs-heading-anchor" href="#Conversion-Process">Conversion Process</a><a id="Conversion-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-Process" title="Permalink"></a></h1><p>At it&#39;s core, MPSGE represents economic models using only prices and quantities. A standard MPSGE input block is structured as follows:</p><pre><code class="language-julia hljs">@input(P, Qref, nest, reference_price=rp, taxes = [Tax(consumer, tax_rate)])</code></pre><p>where <code>reference_price</code> and <code>taxes</code> are optional, <code>P</code> is a commodity variable representing the price paid from the goods, <code>Qref</code> is the reference quantity and <code>nest</code> is the parent nest of the commodity. MPSGE uses this to build the tax-adjusted price, which in this example would be:</p><p class="math-container">\[\bar{P} = \frac{P(1+\text{tax\_rate})}{rp}\]</p><p>The reference price is typically used to negate a tax or subsidy on a good at the benchmark equilibrium, so that the benchmark price is 1. This is useful for calibration, as all prices will be unital at the benchmark. However, adjusting the price with the reference price also alters the reference quantity,</p><p class="math-container">\[\overline{Qref} = Qref \cdot rp\]</p><p>This ensures that the overall value of the transaction remains the same.</p><p>With this in mind, we can begin converting our NLP model to MPSGE. We are going to initially write the model ignoring taxes and price adjustments, and then add them in later. This will demonstrate the power and flexibility of MPSGE, you can easily add or remove taxes and price adjustments without needing to re-derive the entire model.</p><h2 id="Ignoring-Parameters"><a class="docs-heading-anchor" href="#Ignoring-Parameters">Ignoring Parameters</a><a id="Ignoring-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Ignoring-Parameters" title="Permalink"></a></h2><p>First we define our model:</p><pre><code class="language-julia hljs">using MPSGE

mpsge = MPSGEModel()</code></pre><p>Reading the description of the model, there are two <code>sectors</code>: the &quot;Activity&quot; account and &quot;Goods&quot; account. We will follow the convention of naming the activity account <code>X</code> and the goods account <code>Q</code>. Let&#39;s add these two:</p><pre><code class="language-julia hljs">@sectors(mpsge, begin
    X, (description = &quot;Activity Sector&quot;)
    Q, (description = &quot;Goods Sector&quot;)
end)</code></pre><p>The NLP model has 7 prices:</p><ul><li><code>PX</code> - Producer price index, can be viewed as the value added price</li><li><code>PQ</code> - Consumer price index, or the Armington composite price</li><li><code>PFX</code> - Exchange rate</li><li><code>PDD</code> - Domestic good price</li><li><code>PMD</code> - Import price including duties, <span>$PMD = PFX\cdot PWM\cdot (1 + TM)$</span></li><li><code>PED</code> - Export price including subsidies, <span>$PED = PFX\cdot PWE\cdot (1 + TE)$</span></li><li><code>PDT</code> - Domestic price including taxes, <span>$PDT = PDD\cdot (1 + TD)$</span></li></ul><p>Since 3 of these prices are actually tax-adjusted values, we are going to have 4 commodities in MPSGE: <code>PX</code>, <code>PQ</code>, <code>PFX</code>, and <code>PDD</code>. A commodity in MPSGE can be thought of as a price. Let&#39;s add the four commodities:</p><pre><code class="language-julia hljs">@commodities(mpsge, begin
    PX, (description = &quot;Producer Price Index&quot;)
    PQ, (description = &quot;Consumer Price Index&quot;)
    PFX, (description = &quot;Exchange Rate&quot;)
    PDD, (description = &quot;Domestic Good Price&quot;)
end)</code></pre><p>The final variable is the consumer. Based on the model description and SAM, it appears there are three consumers: &quot;Households&quot;, &quot;Government&quot;, and &quot;Rest of World&quot;. However, each of these is really just a different source of income for the single consumer in the model. Therefore, we will just add one consumer, <code>Y</code>:</p><pre><code class="language-julia hljs">@consumer(mpsge, Y, description = &quot;Representative Agent&quot;)</code></pre><p>This consumer will receive the tax revenue, endow the market with the initial production and the trade imbalance, and demand the consumed goods. We will discuss the consumer in more detail below. I will also note that we would typically call this consumer <code>RA</code> for &quot;representative agent&quot;, but to keep consistent with the NLP model, we will call it <code>Y</code>.</p><h3 id="The-X-Sector"><a class="docs-heading-anchor" href="#The-X-Sector">The <code>X</code> Sector</a><a id="The-X-Sector-1"></a><a class="docs-heading-anchor-permalink" href="#The-X-Sector" title="Permalink"></a></h3><p>Let&#39;s start by determining the inputs and outputs of the <code>X</code> sector. The SAM is not structured to show inputs and outputs, it only shows inputs and we need to infer the appropriate output. </p><p>From a high-level perspective, the <code>X</code> sector takes in goods and labor and produces goods that are demanded elsewhere. In this very simply model, <code>X</code> takes in no goods, only labor, with an initial value of <span>$X_0 = 100$</span>. The goods produced by <code>X</code> can either be exported or go into the domestic supply market. </p><p>Here is the production block for <code>X</code>:</p><pre><code class="language-julia hljs">@production(mpsge, X, [t=1,s=0], begin
    @output(PFX, E0, t)
    @output(PDD, DS0, t)
    @input(PX, X0, s)
end)</code></pre><p>Let&#39;s break this down. The <code>@production</code> macro takes four arguments:</p><ol><li>The model, <code>mpsge</code></li><li>The sector, <code>X</code></li><li>A vector defining the nesting structure and elasticities. Here we just use <code>[t=1,s=0]</code> to indicate an elasticity of transformation of 1 and substitution of 0. This will get modified with a parameter later.</li><li>A block defining the inputs and outputs.</li></ol><p>There is a <code>@input</code> with price <code>PX</code> and quantity <code>X0</code>, and two outputs with prices <code>PFX</code> and <code>PDD</code> and quantities <code>E0</code> and <code>DS0</code>. This is the exact structure we discussed and the quantities are as given in the NLP model description. </p><p>The NLP model has the following constraint:</p><p class="math-container">\[X\cdot PX = (PED\cdot E + PDD\cdot DS)\]</p><p>This (almost) exactly matches the inputs and outputs we defined. The difference being a reference to <code>PED</code> instead of <code>PFX</code>. However, since we are ignoring taxes for now and the world export price, we can treat <code>PED</code> as <code>PFX</code>. This constraint indicates the activity of the <code>X</code> sector. </p><h3 id="The-Q-Sector"><a class="docs-heading-anchor" href="#The-Q-Sector">The <code>Q</code> Sector</a><a id="The-Q-Sector-1"></a><a class="docs-heading-anchor-permalink" href="#The-Q-Sector" title="Permalink"></a></h3><p>The <code>Q</code> sector describes the flow of goods, the inputs are where the goods come from and the outputs are where the goods go. Similar to the previous discussion,  we have a constraint that describes the flow of goods:</p><p class="math-container">\[PDT\cdot DD + PMD\cdot M = PQ\cdot Q\]</p><p>In words, goods come from domestic supply <code>DD</code> and imports <code>M</code>, and go to consumption <code>Q</code>. Ignoring taxes again, we can treat <code>PDT</code> as <code>PDD</code> and <code>PMD</code> as <code>PFX</code>. Therefore, we can define the production block for <code>Q</code> as:</p><pre><code class="language-julia hljs">@production(mpsge, Q, [t=0,s=1], begin
  @output(PQ, Q0, t)
  @input(PDD, DD0, s)
  @input(PFX, M0, s)
end)</code></pre><h3 id="The-Y-Consumer"><a class="docs-heading-anchor" href="#The-Y-Consumer">The <code>Y</code> Consumer</a><a id="The-Y-Consumer-1"></a><a class="docs-heading-anchor-permalink" href="#The-Y-Consumer" title="Permalink"></a></h3><p>It may appear that we require new logic to define the consumer, but in reality we are still looking for inputs (final demands) and outputs (endowments). The sneaky way to do this is to find any inputs/outputs with no outputs/inputs, like <code>PX</code> and <code>PQ</code>. In this example, <code>PX</code> is only an input to the <code>X</code> sector, so it must be an endowment from the consumer. Similarly, <code>PQ</code> is only an output from the <code>Q</code> sector, so it must be a final demand from the consumer. Therefore, we can define the demand block as:</p><pre><code class="language-julia hljs">@demand(mpsge, Y, begin
   @final_demand(PQ, Q0)
   @endowment(PX, X0)
end)
 ```

### The &quot;Final&quot; Model

Putting this all together, we have the following MPSGE model:</code></pre><p>julia using MPSGE</p><p>mpsge = MPSGEModel()</p><p>@sectors(mpsge, begin     X, (description = &quot;Activity Sector&quot;)     Q, (description = &quot;Goods Sector&quot;) end)</p><p>@commodities(mpsge, begin     PX, (description = &quot;Producer Price Index&quot;)     PQ, (description = &quot;Consumer Price Index&quot;)     PFX, (description = &quot;Exchange Rate&quot;)     PDD, (description = &quot;Domestic Good Price&quot;) end)</p><p>@consumer(mpsge, Y, description = &quot;Representative Agent&quot;)</p><p>@production(mpsge, X, [t=1,s=0], begin     @output(PFX, E0, t)     @output(PDD, DS0, t)     @input(PX, X0, s) end)</p><p>@production(mpsge, Q, [t=0,s=1], begin     @output(PQ, Q0, t)     @input(PDD, DD0, s)     @input(PFX, M0, s) end)</p><p>@demand(mpsge, Y, begin    @final_demand(PQ, Q0)    @endowment(PX, X0) end)</p><pre><code class="nohighlight hljs">
This is a great first step! This allows us to verify our data is balanced, if not we can easily identify where the problem arise. However, we can&#39;t do anything with this model, there are no parameters we can adjust. So let&#39;d do that now. 

## Adding Parameters

We are going to use the same parameters as the NLP model. To add these, we use the `@parameters` macro to specify name and initial value:</code></pre><p>julia @parameters(mpsge, begin    sigma, .2, (description = &quot;Elasticity of Substitution in Goods Sector&quot;)    omega, .2, (description = &quot;Elasticity of Transformation in Activity Sector&quot;)    BBAR, 0.0, (description = &quot;Trade Imbalance&quot;)</p><p>PWE, 1, (description = &quot;World Export Price Index&quot;)    PWM, 1, (description = &quot;World Import Price Index&quot;)    TM, 0.0, (description = &quot;Import Tariff Rate&quot;)    TE, 0.0, (description = &quot;Export Subsidy Rate&quot;)    TD, 0.0, (description = &quot;Domestic Tax Rate on Demand&quot;) end)</p><pre><code class="nohighlight hljs">
### Adding Domestic Taxes

The domestic tax rate `TD` is going to apply to the domestic good price `PDD` in the `Q` sector. There are many ways to see this, but the easiest is to look at the original constraint:</code></pre><p>math PDT\cdot DD + PMD\cdot M = PQ\cdot Q</p><pre><code class="nohighlight hljs">Notice the `PDT` term, this is the domestic price including taxes. To add this tax, change the input  We do this by adding a tax to the commodity in the production block:</code></pre><p>julia @input(PDD, DD0, s, taxes = [Tax(Y, TD)])</p><pre><code class="nohighlight hljs">The `Tax` function takes two arguments, the consumer receiving the tax revenue and the tax rate. This is all we need to do to add a tax rate. MPSGE will handle the rest. If the value of `TD` were not zero initially, we would add a reference price to adjust the benchmark price to 1, the reference price would be `(1+TD0)`, or the tax-adjustment, where `TD0` is the initial value of `TD`.

### Adding World Import Price Adjustment

Let&#39;s start by looking at the original constraint defining the post-tax import price:</code></pre><p>math PMD = PFX\cdot PWM\cdot (1 + TM)</p><pre><code class="nohighlight hljs">The inclusion of `PWM` is new. The current way to implement this in MPSGE is to use a reference price and adjust the quantity to cancel the effect of the reference price on the value of the transaction. Therefore, will adjust the `@input` for the `PFX` commodity in the `Q` sector production block by adding 
1. A reference price of `1/PWM`
2. A quantity adjustment of `M0*PWM`
3. A tax for the import tariff `TM`</code></pre><p>julia @input(PFX, M0*PWM, s, reference_price = 1/PWM, taxes = [Tax(Y, TM)])</p><pre><code class="nohighlight hljs">I plan to add an externality keyword to the `@input` and `@output` macros to handle price adjustments like this without modifying the reference quantity, but for now this is the way to do it.

### Adding World Export Price Adjustment

This is identical to the import price adjustment, with one big difference: the tax is a subsidy, which means it is negative. Therefore, we add the following to the `@output` for `PFX` in the `X` sector production block:</code></pre><p>julia @output(PFX, E0*PWE, t, reference_price = 1/PWE, taxes = [Tax(Y, -TE)])</p><pre><code class="nohighlight hljs">
### Adding Trade Imbalance
The trade imbalance `BBAR` is added as an endowment to the consumer for the export good and a final demand from the consumer for the import good. Therefore, we add an endowment to the demand block:</code></pre><p>julia @endowment(PFX, BBAR)</p><pre><code class="nohighlight hljs">
### The Final Model</code></pre><p>julia using MPSGE</p><p>X0 = 100 Q0 = 100</p><p>DD0 = 75 DS0 = 75</p><p>E0 = 25 M0 = 25</p><p>mpsge = MPSGEModel()</p><p>@parameters(mpsge, begin     sigma, .2     omega, .2     BBAR, 0.0     PWE, 1     PWM, 1     TM, 0.0     TE, 0.0     TD, 0.0 end)</p><p>@sectors(mpsge, begin     X, (description = &quot;Activity Sector&quot;)     Q, (description = &quot;Goods Sector&quot;) end)</p><p>@commodities(mpsge, begin     PX, (description = &quot;Producer Price Index&quot;)     PQ, (description = &quot;Consumer Price Index&quot;)     PFX, (description = &quot;Exchange Rate&quot;)     PDD, (description = &quot;Domestic Good Price&quot;) end)</p><p>@consumer(mpsge, Y, description = &quot;Representative Agent&quot;)</p><p>@production(mpsge, X, [t=omega,s=0], begin     @output(PFX, E0*PWE, t, reference_price = 1/PWE, taxes = [Tax(Y, -TE)])      @output(PDD, DS0, t)     @input(PX, X0, s) end)</p><p>@production(mpsge, Q, [t=0,s=sigma], begin     @output(PQ, Q0, t)     @input(PFX, M0*PWM, s, reference_price = 1/PWM, taxes = [Tax(Y, TM)])     @input(PDD, DD0, s, taxes = [Tax(Y, TD)])</p><p>end)</p><p>@demand(mpsge, Y, begin     @final_demand(PQ, Q0)     @endowment(PX, X0)     @endowment(PFX, BBAR) end) ```</p><h2 id="Final-Thoughts"><a class="docs-heading-anchor" href="#Final-Thoughts">Final Thoughts</a><a id="Final-Thoughts-1"></a><a class="docs-heading-anchor-permalink" href="#Final-Thoughts" title="Permalink"></a></h2><p>This model is now functionally equivalent to the NLP model described earlier. You can adjust the parameters and solve the model to see how the economy responds. </p><p>In the NLP formulation, there was much effort to carefully define the tax structure and prices. With MPSGE, we can easily add taxes without needing to update the model structure. This makes MPSGE a powerful tool for economic modeling, allowing for rapid experimentation and analysis of different policy scenarios. </p><p>MPSGE also reduces the potential for typos in the model formulation. For example, it would be easy to type variable of <code>DD</code> as <code>DS</code>. <code>DD</code> is used 5 times in the NLP model. In MPSGE, we don&#39;t need to define <code>DD</code> at all. It is implicit in the production block for <code>Q</code>. This is demonstrated when the models are compared in the next section.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problem_description/">« Problem Description</a><a class="docs-footer-nextpage" href="../compare/">Comparing Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 7 November 2025 18:35">Friday 7 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
