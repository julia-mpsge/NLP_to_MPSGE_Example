var documenterSearchIndex = {"docs":
[{"location":"problem_description/#Problem-Description","page":"Problem Description","title":"Problem Description","text":"","category":"section"},{"location":"problem_description/","page":"Problem Description","title":"Problem Description","text":"For now I am going to defer to the PDF reference. I'll be working on updating this section soon.","category":"page"},{"location":"compare/#Comparing-Models","page":"Comparing Models","title":"Comparing Models","text":"","category":"section"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"This document will compare the solutions from NLP_model and MPSGE_model. They both describe the same economic model, but one is implemented in the traditional NLP framework and the other in MPSGE.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"using NLP_to_MPSGE_Example\nusing JuMP, MPSGE, DataFrames","category":"page"},{"location":"compare/#Initialization","page":"Comparing Models","title":"Initialization","text":"","category":"section"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Initialize the data","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"data = ModelData()","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Initialize the models","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"nlp = NLP_model(data);\nmpsge = MPSGE_model(data);\nnothing #hide","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Verify the models by solving the baseline scenario. For the NLP model, you are looking for Optimal Solution Found.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"optimize!(nlp)","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"For the MPSGE model, you are looking for Solver Status: LOCALL_SOLVED, or a Postsolved Residual that is very small (ideally, 0).","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"solve!(mpsge; cumulative_iteration_limit=0)","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"At this point I'll set both models to silent mode to avoid cluttering the output","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"set_silent(nlp)\nset_silent(mpsge)","category":"page"},{"location":"compare/#Comparing-Solutions","page":"Comparing Models","title":"Comparing Solutions","text":"","category":"section"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"The NLP version of the model has more variables the MPSGE version, however, the solutions to both are the same.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Set parameter values for a counterfactual","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"params = ModelParameters(\n    balance_of_payments = 10.0,\n    elas_substitution = 0.5,\n    elas_transformation = 0.5,\n    tax_domestic = .1,\n    tax_import = .2,\n    price_world_export = 1.1,\n    price_world_import = 1.2,\n    subsidy_export = 0.05,\n    )\n\nset_parameter_values(nlp, params)\nset_parameter_values(mpsge, params)\n\noptimize!(nlp)\nsolve!(mpsge)","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"This is a method to view all the variable values in a DataFrame. Let's use this to compare the two models. Note that I've used some fancy operations, I've tried to space things out for clarity, you can extract each piece and run it separately to understand what is happening.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"outerjoin(\n\n    zip(JuMP.name.(all_variables(nlp)), value.(all_variables(nlp))) |>\n        x -> DataFrame(var = first.(x), nlp = last.(x)),\n\n    generate_report(mpsge) |>\n        x -> transform(x, :var => ByRow(y -> JuMP.name(y)) => :var) |>\n        x -> select(x, :var, :value => :mpsge),\n\n    on = :var,\n)","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"The variables present in the MPSGE model can be directly compared to the NLP model. However, neither X nor Q match. This is because in MPSGE, these are activity levels that produce quantities of goods, whereas in the NLP model, these are quantities of goods themselves. Let's focus on X as Q is similar.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Look at the MPSGE model and search for any productions that use X0. That would be the X block","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"production(mpsge[:X])","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Or, in the code:","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"@production(MP, X, [t=omega,s=0], begin        @output(PFX, E0*PWE, t, reference_price = 1/PWE, taxes = [Tax(Y, -TE)]) # Negative tax for export subsidy        @output(PDD, DS0, t)        @input(PX, X0, s)    end)","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"PX is the commodity associated with X0, so to get X we compute the compensated demand for X with respect to PX, and scale it by the activity level of X:","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"X = value(compensated_demand(mpsge[:X], mpsge[:PX])*mpsge[:X])\nQ = value(compensated_demand(mpsge[:Q], mpsge[:PQ])*mpsge[:Q])\n\nprintln(\"X = $X\\nQ = $Q\")","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"The - on Q is signifying that the value comes from an output.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Next up, parameters. MPSGE does not report the parameter values. We can display these using:","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"value.(parameters(mpsge))","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"The above displays only values. It would be a good exercise to put these in a DataFrame with the parameter names, and vcat it to the previous mpsge dataframe.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Next, the four quantities, DD, DS, E, and M. The idea is identical to X and Q. The exception is for E and M, which require scaling by the world prices.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"DD = value(compensated_demand(mpsge[:Q], mpsge[:PDD])*mpsge[:Q])\nDS = value(compensated_demand(mpsge[:X], mpsge[:PDD])*mpsge[:X])\nE = value(compensated_demand(mpsge[:X], mpsge[:PFX])*mpsge[:X]/mpsge[:PWE])\nM = value(compensated_demand(mpsge[:Q], mpsge[:PFX])*mpsge[:Q]/mpsge[:PWM])\n\nprintln(\"DD = $DD\\nDS = $DS\\nE = $E\\nM = $M\")","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"The GR variable in the NLP model corresponds to the tax revenues in MPSGE. There should be a better function for this, but for now we can compute it as:","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"value(MPSGE.tax_revenue(mpsge[:X], mpsge[:Y]; virtual = true)) +\nvalue(MPSGE.tax_revenue(mpsge[:Q], mpsge[:Y]; virtual = true))","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Finally, the three prices. I am first going to demonstrate a method to extract the price directly from the MPSGE model, then show how to compute them manually. This should be a function in MPSGE, I will work on it for a future release. However, notice that we can extract the expression, not just the value.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"P = production(mpsge[:Q])\nO = input(P)\nN = O.children[2]\nCF = cost_function(N)\nPDT = value(CF)\n\nprintln(\"PDT = $PDT\\nCF = $CF\")","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Manually:","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"PDT = value(mpsge[:PDD]*(1 + mpsge[:TD]))\nPMD = value(mpsge[:PFX]*(1 + mpsge[:TM])*mpsge[:PWM])\nPED = value(mpsge[:PFX]*(1 + mpsge[:TE])*mpsge[:PWE])\n\nprintln(\"PDT = $PDT\\nPMD = $PMD\\nPED = $PED\")","category":"page"},{"location":"compare/#Recreating-Results","page":"Comparing Models","title":"Recreating Results","text":"","category":"section"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"In this part we will recreate tables 5.4 and 5.5 from the reference paper. These tables are on pages 42 (45 of document) and 45 (48 of document). These tables show the effects of changing the elasticity parameters and balance of payments on key variables in the model.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"shocks = [\n    ModelParameters(balance_of_payments = 0,    elas_substitution = 0.2, elas_transformation = 0.2,),\n    ModelParameters(balance_of_payments = 10.0, elas_substitution = 0.2, elas_transformation = 0.2,),\n    ModelParameters(balance_of_payments = 10.0, elas_substitution = 0.5, elas_transformation = 0.5,),\n    ModelParameters(balance_of_payments = 10.0, elas_substitution = 2,   elas_transformation = 2,  ),\n    ModelParameters(balance_of_payments = 10.0, elas_substitution = 5,   elas_transformation = 5,  ),\n    ModelParameters(balance_of_payments = 10.0, elas_substitution = 15,  elas_transformation = .2, ),\n    ModelParameters(balance_of_payments = 10.0, elas_substitution = .2,  elas_transformation = 15, ),\n\n    ModelParameters(price_world_import = 1.1, elas_substitution = 0.2, elas_transformation = 0.2,),\n    ModelParameters(price_world_import = 1.1, elas_substitution = 0.5, elas_transformation = 0.5,),\n    ModelParameters(price_world_import = 1.1, elas_substitution = 2,   elas_transformation = 2,  ),\n    ModelParameters(price_world_import = 1.1, elas_substitution = 5,   elas_transformation = 5,  ),\n    ModelParameters(price_world_import = 1.1, elas_substitution = 15,  elas_transformation = .2, ),\n    ModelParameters(price_world_import = 1.1, elas_substitution = .2,  elas_transformation = 15, ),\n];\nnothing #hide","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"To run the shocks and collect the results, we do two steps:","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Create empty DataFrames to hold the results\nLoop through each shock, set the parameters, solve the models, generate the reports, and append them to the results DataFrames.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"However, this requires the DataFrame be empty at the start of each loop. To ensure this, we can use a begin...end block to create a code block.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"begin\n    nlp_results = DataFrame();\n    mpsge_results = DataFrame();\n    for shock in shocks\n        set_parameter_values(nlp, shock)\n        set_parameter_values(mpsge, shock)\n\n        optimize!(nlp)\n        solve!(mpsge)\n\n        nlp_report = report(nlp)\n        mpsge_report = report(mpsge)\n\n        push!(nlp_results, nlp_report[1, :])\n        push!(mpsge_results, mpsge_report[1, :])\n    end\nend","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"The table results can be viewed by simply typing the DataFrame name.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"nlp_results","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"MPSGE results","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"mpsge_results","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"Are these the same? Substract and round:","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"round.(nlp_results .- mpsge_results, digits=6)","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"What do the columns in the report mean? Check the doc string for report. You can do this either by entering the help mode in the REPL, just type ? in the REPL to switch to help mode and type report, or using the @doc report. Here is a link to the report documentation.","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"","category":"page"},{"location":"compare/","page":"Comparing Models","title":"Comparing Models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"problems/#Issues-with-PATHSolver","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"","category":"section"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"While writing and debugging this model I found an issue that I think should be reported. The issue is that when using subexpressions in a PATHSolver MCP model, the solver fails to find a solution even when the same model without subexpressions solves fine. This issue also appears in MPSGE models, which use subexpressions by default.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"using NLP_to_MPSGE_Example\nusing JuMP, MPSGE, DataFrames","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"Initialize the data","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"data = ModelData()","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"Initialize the models","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"nlp = NLP_model(data)\nmcp = MCP_model(data)\nmcp_sub = MCP_model(data; subexpressions = true)\nmpsge = MPSGE_model(data)","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"Notice that we have two versions of the MCP model, one with subexpressions and one without. This is going to demonstrate an issue with the PATHSolver when subexpressions are used.","category":"page"},{"location":"problems/#Demonstration-of-the-Issue","page":"Issues with PATHSolver","title":"Demonstration of the Issue","text":"","category":"section"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"To demonstrate the issue, we will set a counterfactual scenario with a fairly large shock to the parameters, then attempt to solve all four models. This is the smallest shock I could find that causes the issue to appear.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"params = ModelParameters(\n    elas_substitution = .2,\n    elas_transformation = 15,\n    balance_of_payments = 10,\n    price_world_export = 1.2,\n    price_world_import = 1.1,\n    tax_domestic = .5,\n    subsidy_export = .2,\n    tax_import = .1\n    );\n\n\nset_parameter_values(nlp, params)\nset_parameter_values(mcp, params)\nset_parameter_values(mcp_sub, params)\nset_parameter_values(mpsge, params)","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"The NLP model solves fine.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"optimize!(nlp)","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"As does the MCP model without subexpressions.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"optimize!(mcp)","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"However, the MCP model with subexpressions fails to solve.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"optimize!(mcp_sub)","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"This MPSGE model uses subexpressions, so it also fails to solve.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"solve!(mpsge)","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"The issue appears to be related to the use of subexpressions in PATHSolver. Both the NLP and MCP models without subexpressions solve fine, while both models with subexpressions fail to solve.","category":"page"},{"location":"problems/#Temporary-Solution","page":"Issues with PATHSolver","title":"Temporary Solution","text":"","category":"section"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"One way to solve this is to slowly approach the counterfactual by solving the model multiple times with smaller shocks. This is known as \"parameter homotopy\" or \"path-following\". Below is an example of how to do this.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"The following is a function allowing us to set the value of elas_transformation without changing the other parameters.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"transformation_shock(x) = ModelParameters(\n    elas_substitution = .2,\n    elas_transformation = x,\n    balance_of_payments = 10,\n    price_world_export = 1.2,\n    price_world_import = 1.1,\n    tax_domestic = .5,\n    subsidy_export = .2,\n    tax_import = .1\n    )","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"We are going to solve the model many times, so it's a good idea to set it to silent mode.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"set_silent(mpsge)","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"Now we can loop over a range of values for elas_transformation, gradually increasing it to the target value.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"for param in transformation_shock.(1:15)\n    set_parameter_values(mpsge, param)\n    solve!(mpsge)\n\n    jm = jump_model(mpsge)\n    set_start_value.(all_variables(jm), value.(all_variables(jm)))\n\n    println(\"Omega=$(param.elas_transformation): Solved = $(is_solved_and_feasible(jm))\")\n\nend","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"A couple of notes. First, the all_variables function is defined in MPSGE, but it does not grab all the variables, just the ones that are explicitly defined. By using first extracting the JuMP model using jump_model, we can use all_variables from JuMP, which grabs all variables including subexpressions. I plan to add a keyword to all_variables in MPSGE to allow this behavior directly in the future.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"Second, this approach may not always work. It depends on the model and the size of the shock. However, it is a useful technique to have in your toolbox when dealing with difficult-to-solve models.","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"","category":"page"},{"location":"problems/","page":"Issues with PATHSolver","title":"Issues with PATHSolver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"docs/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"docs/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"docs/#NLP_to_MPSGE_Example.ModelData","page":"API Reference","title":"NLP_to_MPSGE_Example.ModelData","text":"ModelData\n\nHolds the initial data for the economic model.\n\nFields\n\ninitial_exports::Float64: Initial exports value.\ninitial_imports::Float64: Initial imports value.\ninitial_production::Float64: Initial production value.\ninitial_consumption::Float64: Initial consumption value.\ndomestic_demand::Float64: Domestic demand value.\ndomestic_supply::Float64: Domestic supply value.\ninitial_consumer_price_index::Float64: Initial consumer price index.\ninitial_world_import_price::Float64: Initial world import price.\ninitial_world_export_price::Float64: Initial world export price.\ninitial_domestic_price::Float64: Initial domestic price.\n\nDefault Values\n\ninitial_exports = 25.0\ninitial_imports = 25.0\ninitial_production = 100.0\ninitial_consumption = 100.0\ndomestic_demand = 75.0\ndomestic_supply = 75.0\ninitial_consumer_price_index = 1.0\ninitial_world_import_price = 1.0\ninitial_world_export_price = 1.0\ninitial_domestic_price = 1.0\n\n\n\n\n\n","category":"type"},{"location":"docs/#NLP_to_MPSGE_Example.ModelParameters","page":"API Reference","title":"NLP_to_MPSGE_Example.ModelParameters","text":"ModelParameters\n\nHolds the parameters for the models.\n\nFields\n\nelas_substitution::Float64: Elasticity of substitution.\nelas_transformation::Float64: Elasticity of transformation.\nbalance_of_payments::Float64: Balance of payments.\nprice_world_export::Float64: World export price.\nprice_world_import::Float64: World import price.\ntax_import::Float64: Import tax.\nsubsidy_export::Float64: Export subsidy.\ntax_domestic::Float64: Domestic tax.\n\nDefault Values\n\nelas_substitution = 0.2\nelas_transformation = 0.2\nbalance_of_payments = 0.0\nprice_world_export = 1.0\nprice_world_import = 1.0\ntax_import = 0.0\nsubsidy_export = 0.0\ntax_domestic = 0.0\n\n\n\n\n\n","category":"type"},{"location":"docs/#NLP_to_MPSGE_Example.MCP_model-Tuple{ModelData}","page":"API Reference","title":"NLP_to_MPSGE_Example.MCP_model","text":"MCP_model(data::ModelData; subexpressions = false)\n\nCreates a Mixed Complementarity Problem (MCP) model based on the provided ModelData. If subexpressions is set to true, intermediate variables for revenues and costs are created for better clarity in the model formulation.\n\nThis model is included as an example of the explict MCP equation generated by MPSGE.  It was initially created to test a bug. This model will solve for most parameter values if subexpressions=false, but may fail to solve for some parameter values if subexpressions=true.\n\nThe report will not work with this model. \n\n\n\n\n\n","category":"method"},{"location":"docs/#NLP_to_MPSGE_Example.MPSGE_model-Tuple{ModelData}","page":"API Reference","title":"NLP_to_MPSGE_Example.MPSGE_model","text":"MPSGE_model(data::ModelData)\n\nCreates an MPSGEModel based on the provided ModelData. The numeraire is PQ,  the consumer price index, which is fixed to 1.\n\nParameters\n\nsigma: Elasticity of substitution\nomega: Elasticity of transformation\nBBAR: Balance of payments\nPWE: World export price\nPWM: World import price\nTM: Import tax rate\nTE: Export subsidy rate\nTD: Domestic tax rate\n\nSectors\n\nX: Production sector\nQ: Consumption sector\n\nCommodities\n\nPFX: Nominal exchange rate\nPX: Producer price index\nPQ: Consumer price index\nPDD: Domestic price excluding taxes\n\nConsumers\n\nY: Representative Agent\n\n\n\n\n\n","category":"method"},{"location":"docs/#NLP_to_MPSGE_Example.NLP_model-Tuple{ModelData}","page":"API Reference","title":"NLP_to_MPSGE_Example.NLP_model","text":"NLP_model(data::ModelData)\n\nCreates a JuMP model representing the NLP economic model based on the provided ModelData.\n\nThe numeraire is PQ, the consumer price index, which is fixed to 1.\n\nParameters\n\nsigma: Elasticity of substitution\nomega: Elasticity of transformation\nBBAR: Balance of payments\nPWE: World export price\nPWM: World import price\nTM: Import tax rate\nTE: Export subsidy rate\nTD: Domestic tax rate\n\nVariables\n\nDD: Domestic Demand\nDS: Domestic Supply\nM: Imports\nE: Exports\nX: Compound good (production)\nY: PNB\nPX: Producer price index\nPQ: Consumer price index\nPED: Export price including subsidy\nPMD: Import price including duties\nPDT: Domestic Price including taxes\nPDD: Domestic Price excluding taxes\nPFX: Nominal exchange rate\nQ: Consumption of the compound good\nGR: Government Revenue\n\n\n\n\n\n","category":"method"},{"location":"docs/#NLP_to_MPSGE_Example.report-Tuple{JuMP.Model}","page":"API Reference","title":"NLP_to_MPSGE_Example.report","text":"report(M::JuMP.Model)\nreport(M::MPSGEModel)\n\nGenerates a report DataFrame summarizing key variables from the provided model M.\n\nColumns\n\nsigma: Elasticity of substitution\nomega: Elasticity of transformation\nBBAR: Balance of payments\nPWM: World import price\nPWE: World export price\nTX: Export subsidy\nTM: Import tax\nTD: Domestic tax\nPED: Export price including subsidy\nPMD: Import price including duties\nQ: Consumption of the compound good\nPD: Domestic price excluding taxes\nTCR: Real exchange rate\nTCRE: Real exchange rate for exports\nTCRM: Real exchange rate for imports\nTCERQ: Real effective echange rate for consumption\nTCERX: Real effective exchange rate for production\nTCN: Nominal exchange rate\nE: Exports\nDD: Domestic demand\nM: Imports\n\n\n\n\n\n","category":"method"},{"location":"convert/#Conversion-Process","page":"Conversion Process","title":"Conversion Process","text":"","category":"section"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"At it's core, MPSGE represents economic models using only prices and quantities. A standard MPSGE input block is structured as follows:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@input(P, Qref, nest, reference_price=rp, taxes = [Tax(consumer, tax_rate)])","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"where reference_price and taxes are optional, P is a commodity variable representing the price paid from the goods, Qref is the reference quantity and nest is the parent nest of the commodity. MPSGE uses this to build the tax-adjusted price, which in this example would be:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"barP = fracP(1+texttax_rate)rp","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"The reference price is typically used to negate a tax or subsidy on a good at the benchmark equilibrium, so that the benchmark price is 1. This is useful for calibration, as all prices will be unital at the benchmark. However, adjusting the price with the reference price also alters the reference quantity,","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"overlineQref = Qref cdot rp","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"This ensures that the overall value of the transaction remains the same.","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"With this in mind, we can begin converting our NLP model to MPSGE. We are going to initially write the model ignoring taxes and price adjustments, and then add them in later. This will demonstrate the power and flexibility of MPSGE, you can easily add or remove taxes and price adjustments without needing to re-derive the entire model.","category":"page"},{"location":"convert/#Ignoring-Parameters","page":"Conversion Process","title":"Ignoring Parameters","text":"","category":"section"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"First we define our model:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"using MPSGE\n\nmpsge = MPSGEModel()","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"Reading the description of the model, there are two sectors: the \"Activity\" account and \"Goods\" account. We will follow the convention of naming the activity account X and the goods account Q. Let's add these two:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@sectors(mpsge, begin\n    X, (description = \"Activity Sector\")\n    Q, (description = \"Goods Sector\")\nend)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"The NLP model has 7 prices:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"PX - Producer price index, can be viewed as the value added price\nPQ - Consumer price index, or the Armington composite price\nPFX - Exchange rate\nPDD - Domestic good price\nPMD - Import price including duties, PMD = PFXcdot PWMcdot (1 + TM)\nPED - Export price including subsidies, PED = PFXcdot PWEcdot (1 + TE)\nPDT - Domestic price including taxes, PDT = PDDcdot (1 + TD)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"Since 3 of these prices are actually tax-adjusted values, we are going to have 4 commodities in MPSGE: PX, PQ, PFX, and PDD. A commodity in MPSGE can be thought of as a price. Let's add the four commodities:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@commodities(mpsge, begin\n    PX, (description = \"Producer Price Index\")\n    PQ, (description = \"Consumer Price Index\")\n    PFX, (description = \"Exchange Rate\")\n    PDD, (description = \"Domestic Good Price\")\nend)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"The final variable is the consumer. Based on the model description and SAM, it appears there are three consumers: \"Households\", \"Government\", and \"Rest of World\". However, each of these is really just a different source of income for the single consumer in the model. Therefore, we will just add one consumer, Y:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@consumer(mpsge, Y, description = \"Representative Agent\")","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"This consumer will receive the tax revenue, endow the market with the initial production and the trade imbalance, and demand the consumed goods. We will discuss the consumer in more detail below. I will also note that we would typically call this consumer RA for \"representative agent\", but to keep consistent with the NLP model, we will call it Y.","category":"page"},{"location":"convert/#The-X-Sector","page":"Conversion Process","title":"The X Sector","text":"","category":"section"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"Let's start by determining the inputs and outputs of the X sector. The SAM is not structured to show inputs and outputs, it only shows inputs and we need to infer the appropriate output. ","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"From a high-level perspective, the X sector takes in goods and labor and produces goods that are demanded elsewhere. In this very simply model, X takes in no goods, only labor, with an initial value of X_0 = 100. The goods produced by X can either be exported or go into the domestic supply market. ","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"Here is the production block for X:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@production(mpsge, X, [t=1,s=0], begin\n    @output(PFX, E0, t)\n    @output(PDD, DS0, t)\n    @input(PX, X0, s)\nend)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"Let's break this down. The @production macro takes four arguments:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"The model, mpsge\nThe sector, X\nA vector defining the nesting structure and elasticities. Here we just use [t=1,s=0] to indicate an elasticity of transformation of 1 and substitution of 0. This will get modified with a parameter later.\nA block defining the inputs and outputs.","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"There is a @input with price PX and quantity X0, and two outputs with prices PFX and PDD and quantities E0 and DS0. This is the exact structure we discussed and the quantities are as given in the NLP model description. ","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"The NLP model has the following constraint:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"Xcdot PX = (PEDcdot E + PDDcdot DS)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"This (almost) exactly matches the inputs and outputs we defined. The difference being a reference to PED instead of PFX. However, since we are ignoring taxes for now and the world export price, we can treat PED as PFX. This constraint indicates the activity of the X sector. ","category":"page"},{"location":"convert/#The-Q-Sector","page":"Conversion Process","title":"The Q Sector","text":"","category":"section"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"The Q sector describes the flow of goods, the inputs are where the goods come from and the outputs are where the goods go. Similar to the previous discussion,  we have a constraint that describes the flow of goods:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"PDTcdot DD + PMDcdot M = PQcdot Q","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"In words, goods come from domestic supply DD and imports M, and go to consumption Q. Ignoring taxes again, we can treat PDT as PDD and PMD as PFX. Therefore, we can define the production block for Q as:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@production(mpsge, Q, [t=0,s=1], begin\n  @output(PQ, Q0, t)\n  @input(PDD, DD0, s)\n  @input(PFX, M0, s)\nend)","category":"page"},{"location":"convert/#The-Y-Consumer","page":"Conversion Process","title":"The Y Consumer","text":"","category":"section"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"It may appear that we require new logic to define the consumer, but in reality we are still looking for inputs (final demands) and outputs (endowments). The sneaky way to do this is to find any inputs/outputs with no outputs/inputs, like PX and PQ. In this example, PX is only an input to the X sector, so it must be an endowment from the consumer. Similarly, PQ is only an output from the Q sector, so it must be a final demand from the consumer. Therefore, we can define the demand block as:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@demand(mpsge, Y, begin\n   @final_demand(PQ, Q0)\n   @endowment(PX, X0)\nend)\n ```\n\n### The \"Final\" Model\n\nPutting this all together, we have the following MPSGE model:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"julia using MPSGE","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"mpsge = MPSGEModel()","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@sectors(mpsge, begin     X, (description = \"Activity Sector\")     Q, (description = \"Goods Sector\") end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@commodities(mpsge, begin     PX, (description = \"Producer Price Index\")     PQ, (description = \"Consumer Price Index\")     PFX, (description = \"Exchange Rate\")     PDD, (description = \"Domestic Good Price\") end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@consumer(mpsge, Y, description = \"Representative Agent\")","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@production(mpsge, X, [t=1,s=0], begin     @output(PFX, E0, t)     @output(PDD, DS0, t)     @input(PX, X0, s) end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@production(mpsge, Q, [t=0,s=1], begin     @output(PQ, Q0, t)     @input(PDD, DD0, s)     @input(PFX, M0, s) end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@demand(mpsge, Y, begin    @final_demand(PQ, Q0)    @endowment(PX, X0) end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"\nThis is a great first step! This allows us to verify our data is balanced, if not we can easily identify where the problem arise. However, we can't do anything with this model, there are no parameters we can adjust. So let'd do that now. \n\n## Adding Parameters\n\nWe are going to use the same parameters as the NLP model. To add these, we use the `@parameters` macro to specify name and initial value:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"julia @parameters(mpsge, begin    sigma, .2, (description = \"Elasticity of Substitution in Goods Sector\")    omega, .2, (description = \"Elasticity of Transformation in Activity Sector\")    BBAR, 0.0, (description = \"Trade Imbalance\")","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"PWE, 1, (description = \"World Export Price Index\")    PWM, 1, (description = \"World Import Price Index\")    TM, 0.0, (description = \"Import Tariff Rate\")    TE, 0.0, (description = \"Export Subsidy Rate\")    TD, 0.0, (description = \"Domestic Tax Rate on Demand\") end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"\n### Adding Domestic Taxes\n\nThe domestic tax rate `TD` is going to apply to the domestic good price `PDD` in the `Q` sector. There are many ways to see this, but the easiest is to look at the original constraint:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"math PDT\\cdot DD + PMD\\cdot M = PQ\\cdot Q","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"Notice the `PDT` term, this is the domestic price including taxes. To add this tax, change the input  We do this by adding a tax to the commodity in the production block:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"julia @input(PDD, DD0, s, taxes = [Tax(Y, TD)])","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"The `Tax` function takes two arguments, the consumer receiving the tax revenue and the tax rate. This is all we need to do to add a tax rate. MPSGE will handle the rest. If the value of `TD` were not zero initially, we would add a reference price to adjust the benchmark price to 1, the reference price would be `(1+TD0)`, or the tax-adjustment, where `TD0` is the initial value of `TD`.\n\n### Adding World Import Price Adjustment\n\nLet's start by looking at the original constraint defining the post-tax import price:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"math PMD = PFX\\cdot PWM\\cdot (1 + TM)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"The inclusion of `PWM` is new. The current way to implement this in MPSGE is to use a reference price and adjust the quantity to cancel the effect of the reference price on the value of the transaction. Therefore, will adjust the `@input` for the `PFX` commodity in the `Q` sector production block by adding \n1. A reference price of `1/PWM`\n2. A quantity adjustment of `M0*PWM`\n3. A tax for the import tariff `TM`","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"julia @input(PFX, M0*PWM, s, reference_price = 1/PWM, taxes = [Tax(Y, TM)])","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"I plan to add an externality keyword to the `@input` and `@output` macros to handle price adjustments like this without modifying the reference quantity, but for now this is the way to do it.\n\n### Adding World Export Price Adjustment\n\nThis is identical to the import price adjustment, with one big difference: the tax is a subsidy, which means it is negative. Therefore, we add the following to the `@output` for `PFX` in the `X` sector production block:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"julia @output(PFX, E0*PWE, t, reference_price = 1/PWE, taxes = [Tax(Y, -TE)])","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"\n### Adding Trade Imbalance\nThe trade imbalance `BBAR` is added as an endowment to the consumer for the export good and a final demand from the consumer for the import good. Therefore, we add an endowment to the demand block:","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"julia @endowment(PFX, BBAR)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"\n### The Final Model","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"julia using MPSGE","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"X0 = 100 Q0 = 100","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"DD0 = 75 DS0 = 75","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"E0 = 25 M0 = 25","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"mpsge = MPSGEModel()","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@parameters(mpsge, begin     sigma, .2     omega, .2     BBAR, 0.0     PWE, 1     PWM, 1     TM, 0.0     TE, 0.0     TD, 0.0 end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@sectors(mpsge, begin     X, (description = \"Activity Sector\")     Q, (description = \"Goods Sector\") end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@commodities(mpsge, begin     PX, (description = \"Producer Price Index\")     PQ, (description = \"Consumer Price Index\")     PFX, (description = \"Exchange Rate\")     PDD, (description = \"Domestic Good Price\") end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@consumer(mpsge, Y, description = \"Representative Agent\")","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@production(mpsge, X, [t=omega,s=0], begin     @output(PFX, E0*PWE, t, reference_price = 1/PWE, taxes = [Tax(Y, -TE)])      @output(PDD, DS0, t)     @input(PX, X0, s) end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@production(mpsge, Q, [t=0,s=sigma], begin     @output(PQ, Q0, t)     @input(PFX, M0*PWM, s, reference_price = 1/PWM, taxes = [Tax(Y, TM)])     @input(PDD, DD0, s, taxes = [Tax(Y, TD)])","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"end)","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"@demand(mpsge, Y, begin     @final_demand(PQ, Q0)     @endowment(PX, X0)     @endowment(PFX, BBAR) end) ```","category":"page"},{"location":"convert/#Final-Thoughts","page":"Conversion Process","title":"Final Thoughts","text":"","category":"section"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"This model is now functionally equivalent to the NLP model described earlier. You can adjust the parameters and solve the model to see how the economy responds. ","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"In the NLP formulation, there was much effort to carefully define the tax structure and prices. With MPSGE, we can easily add taxes without needing to update the model structure. This makes MPSGE a powerful tool for economic modeling, allowing for rapid experimentation and analysis of different policy scenarios. ","category":"page"},{"location":"convert/","page":"Conversion Process","title":"Conversion Process","text":"MPSGE also reduces the potential for typos in the model formulation. For example, it would be easy to type variable of DD as DS. DD is used 5 times in the NLP model. In MPSGE, we don't need to define DD at all. It is implicit in the production block for Q. This is demonstrated when the models are compared in the next section.","category":"page"}]
}
